var MAX_PARTICLES = 500;var MAX_VELOCITY = 500;var PARTICLE_RADIUS = 6;var STAGE_WIDTH = 1024;var STAGE_HEIGHT = 768;var COLORS = [0xcc0000, 0xffcc00, 0xaaff00, 0x0099cc, 0x194c99, 0x661999];var FRAME_TIMES = [];var SHADOWS = false;var particles = [];// Have to initialise this way because of a bug in Firefox that doesn't let you get the stage width/height immediatelystage.addEventListener(Event.RESIZE, init);stage.dispatchEvent(new Event(Event.RESIZE));function init(event){	// To circumvent a bug in Firefox	if (stage.stageHeight <= 0 && stage.stageWidth <= 0)	{		return false;	}		stage.removeEventListener(Event.RESIZE, init);	var location = "";		// Check for URL parameters in the browser via JavaScript	if (ExternalInterface.available)	{		try		{			var getLocation = ExternalInterface.call("getLocation");						if (getLocation != null)			{				location = ExternalInterface.call("getLocation");			}		}		catch (error)		{		}	}	// If shadows are turned on	if (location.match(/shadows=true/))	{		SHADOWS = true;	}		// If max_particles is specified	if (location.match(/particles=/))	{		var maxParticles = location.match(/particles=([^&]+)/)[1];		maxParticles = parseInt(maxParticles);				if (!isNaN(maxParticles))		{			MAX_PARTICLES = maxParticles;		}	}		STAGE_WIDTH = stage.stageWidth;	STAGE_HEIGHT = stage.stageHeight;	// Create the particles	for (var i = 0; i < MAX_PARTICLES; i++)	{		particles.push(Particle());	}		// Create the framerate element	var format = new TextFormat();	format.font = "Arial";	format.size = 25;	var frameRate = new TextField();	frameRate.name = "frameRate";	frameRate.autoSize = "right";	frameRate.defaultTextFormat = format;	frameRate.text = "FPS";	frameRate.width = 50;	frameRate.x = STAGE_WIDTH - frameRate.width - 10;	frameRate.y = STAGE_HEIGHT - frameRate.height - 10;	stage.addChild(frameRate);	animate();}function animate(){	// Limit the frame time array to the last 30 frames	if (FRAME_TIMES.length > 30)	{		FRAME_TIMES.splice(0, 1);	}		var currTime = new Date().getTime();		FRAME_TIMES.push(currTime);		// Calculate the framerate based upon the difference between the absolute times of the oldest and newest frames, subdivided by how many frames were drawn inbetween	var frameRateText = 1000 / ((currTime - FRAME_TIMES[0]) / (FRAME_TIMES.length -1)) + "";	frameRateText = frameRateText.replace(/(^[^.]+\...).*/, "$1");	frameRateText += " FPS";	var frameRate = stage.getChildByName("frameRate");	frameRate.text = frameRateText;		var timeDelta = currTime - FRAME_TIMES[FRAME_TIMES.length - 2];		if (isNaN(timeDelta))	{		timeDelta = 0;	}		// Draw each particle	for (var particle in particles)	{		particles[particle].draw(timeDelta);	}		setTimeout(animate, 1);}function Particle(){	var angle = Math.PI * 2 * Math.random();	var velocity = MAX_VELOCITY / 8 * 7 * Math.random() + MAX_VELOCITY / 8;	var x = STAGE_WIDTH / 2 - PARTICLE_RADIUS;	var y = STAGE_HEIGHT / 2 - PARTICLE_RADIUS;		// Create visual element for the particle	var domNode = new Shape();	domNode.graphics.beginFill(COLORS[Math.floor(Math.random() * COLORS.length)]);	domNode.graphics.drawCircle(0, 0, PARTICLE_RADIUS);		if (SHADOWS)	{		var dropShadow:DropShadowFilter = new DropShadowFilter();		dropShadow.alpha = 0.33;		dropShadow.blurX = 3;		dropShadow.blurY = 3;		dropShadow.distance = 6;		domNode.filters = [dropShadow];	}		stage.addChild(domNode);		// Set initial position to middle of screen	domNode.x = x;	domNode.y = y;		function draw(timeDelta)	{		// Calculate next position of particle		var nextX = x + Math.cos(angle) * velocity * (timeDelta / 1000);		var nextY = y + Math.sin(angle) * velocity * (timeDelta / 1000);				// If particle is going to move off right side of screen		if (nextX + PARTICLE_RADIUS * 2 > STAGE_WIDTH)		{			// If angle is between 3 o'clock and 6 o'clock			if ((angle >= 0 && angle < Math.PI / 2))			{				angle = Math.PI - angle;			}			// If angle is between 12 o'clock and 3 o'clock			else if (angle > Math.PI / 2 * 3)			{				angle = angle - (angle - Math.PI / 2 * 3) * 2			}		}				// If particle is going to move off left side of screen		if (nextX < 0)		{			// If angle is between 6 o'clock and 9 o'clock			if ((angle > Math.PI / 2 && angle < Math.PI))			{				angle = Math.PI - angle;			}			// If angle is between 9 o'clock and 12 o'clock			else if (angle > Math.PI && angle < Math.PI / 2 * 3)			{				angle = angle + (Math.PI / 2 * 3 - angle) * 2			}		}				// If particle is going to move off bottom side of screen		if (nextY + PARTICLE_RADIUS * 2 > STAGE_HEIGHT)		{			// If angle is between 3 o'clock and 9 o'clock			if ((angle > 0 && angle < Math.PI))			{				angle = Math.PI * 2 - angle;			}		}				// If particle is going to move off top side of screen		if (nextY < 0)		{			// If angle is between 9 o'clock and 3 o'clock			if ((angle > Math.PI && angle < Math.PI * 2))			{				angle = angle - (angle - Math.PI) * 2;			}		}				domNode.x = nextX;		domNode.y = nextY;				x = nextX;		y = nextY;	}		return {		draw: draw	}}